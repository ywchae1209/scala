# Annotation on Functional Programming (with Scala) 

John A. De Goesê°€ ì •ë¦¬í•œ Applied-FP-with-Scala.md ë¥¼ ì°¸ê³ í•˜ì—¬, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ê°œê´„ì  ì •ë¦¬ë¥¼ ëª‡ì°¨ë¡€ì— ë‚˜ëˆ„ì–´ì„œ í•´ë³´ë ¤ í•œë‹¤.
[https://gist.github.com/jdegoes/97459c0045f373f4eaf126998d8f65dc]

# Intro to Functional Programming ( FP )

Softwareë¥¼ êµ¬ì„±í•˜ëŠ” í•µì‹¬ìš”ì†ŒëŠ” ê²°êµ­ `function`ê³¼ `Data Structure`ë“¤ì˜ ì¡°í•©ì´ë‹¤.  
Functional Programmingì€ ìˆ˜í•™ì  ì˜ë¯¸ì˜ í•¨ìˆ˜( ê°™ì€ ì…ë ¥ì— ëŒ€í•´ì„œ í•­ìƒ ê°™ì€ ê²°ê³¼ 1ê°œë¥¼ ë‚´ì–´ ë†“ëŠ”ë‹¤;  `pure function` ì´ë¼ê³  ë¶€ë¦„)ë¥¼ ê·¹ë‹¨ì ìœ¼ë¡œ ì¶”êµ¬í•˜ëŠ” ê°œë°œíŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤.

> í†µìƒ í”„ë¡œê·¸ë¨ì—ì„œ `í•¨ìˆ˜`ëŠ” ìƒí™©ì— ë”°ë¼ ë‹¤ë¥¸ ê²°ê³¼ë¥¼ ë‚´ê±°ë‚˜, ì‹¤íŒ¨í•˜ê¸°ë„ í•˜ë¯€ë¡œ `ìˆœìˆ˜í•¨ìˆ˜`ê°€ ì•„ë‹Œ ê²½ìš°ê°€ ë§ë‹¤.
> í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ë°˜ë“œì‹œ `ìˆœìˆ˜í•¨ìˆ˜`ë¡œë§Œ softwareë¥¼ ê°œë°œí•œë‹¤ëŠ” ì ì´ ë‹¤ë¥´ë‹¤.


`ìˆœìˆ˜í•¨ìˆ˜`(ì´í•˜ì—ì„œëŠ” ë‹¨ìˆœíˆ `í•¨ìˆ˜`ë¼ê³  í•˜ê² ìŒ)ë“¤ë¡œë§Œ ê°œë°œí•˜ë¯€ë¡œ,
1. `í•¨ìˆ˜`ë¥¼ ìš©ì´í•˜ê²Œ ì œì‘í•˜ê³  ë‹¤ë£¨ëŠ” ì—¬ëŸ¬ ê¸°ë²•ë“¤ì´ ì¡´ì¬í•˜ê³  ( ex: Lambda function, ...)
2. í•¨ìˆ˜ì˜ ìœ í˜•ì„ ë‹¤ë£¨ê¸° ìœ„í•œ ì—¬ëŸ¬ê°€ì§€ `íƒ€ì…`ë“¤ì´ ì¡´ì¬í•˜ë©°, ( ex: Higher order type )
3. `í•¨ìˆ˜`ë“¤ì„ ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ `ì¡°í•©`í•˜ëŠ” ê¸°ë²•ë“¤ê³¼ ( ex: Higher order function, ... )
4. í•¨ìˆ˜ì˜ `ì¡°í•©`ì„ ë‹¤ë£¨ëŠ” ë‹¤ì–‘í•œ íŒ¨í„´ë“¤ì´ ì¡´ì¬í•œë‹¤. ( ex: Functor, Applicative, Monad ...)

> `í•¨ìˆ˜í˜• ì–¸ì–´`ì˜ ì´ëŸ¬í•œ ë…íŠ¹í•œ ì§€ì ì€ ì¼ë°˜ì ì¸ ì–¸ì–´ì™€ ê·¹ëª…í•˜ê²Œ ì°¨ì´ë‚˜ëŠ” ë¶€ë¶„.

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ì´ìš©í•œ ì†Œí”„íŠ¸ì›¨ì–´ì˜ íŠ¹ì„±
> 1. ê·¹ë‹¨ì ì¸ robustness ì œê³µ 
> 2. ì—„ì²­ë‚˜ê²Œ ê°„ê²°í•œ ì½”ë“œ 
> 3. ë›°ì–´ë‚œ ì˜ˆì™¸ì•ˆì •ì„±, í™•ì¥ì„±

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ê³µê²©
> 1. ì„±ëŠ¥ overhead : í•˜ë‚˜ì˜ layerê°€ ì¶”ê°€ëœ ì…ˆì´ë¯€ë¡œ ( ìµœì í™” ê¸°ë²•ì´ ìˆìŒ)
> 2. ê°€íŒŒë¥¸ í•™ìŠµê³¡ì„ 

ì´í•˜ì—ì„œëŠ” `í•¨ìˆ˜`ì™€ `íƒ€ì…`ì— ëŒ€í•´ ì‚´í´ë³¸ë‹¤.

----
# 1. functions

## function

```mermaid
flowchart TD
  A[domain:ì •ì˜ì—­] --> |function| B(codomain: ê³µì—­)

```

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ í•¨ìˆ˜ëŠ” ìˆ˜í•™ì  ì˜ë¯¸ì˜ í•¨ìˆ˜ì™€ ê°™ë‹¤.
ì´ë¥¼ ê°•ì¡°í•˜ê¸° ìœ„í•´ `pure function`ì´ë¼ê³  í•˜ë©°, ì´í•˜ì— í•¨ìˆ˜ëŠ” ëª¨ë‘ `pure function`ì„ ë§í•œë‹¤.


> A (`pure`) function is a mapping from one set, called a `domain` to another set, called the `codomain`.
> In Scala, both `domain` and `codomain` are `types`.

```scala
val square : Int => Int = x => x * x    // x => x * x is lambda.
square(2) // 4
```

`í•¨ìˆ˜ instance`ë¥¼ ìƒì„±í•˜ê³ , ë³€ìˆ˜ì— ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. 
- `labmbda function`ì€ ìµëª…ìœ¼ë¡œ ì •ì˜í•œ í•¨ìˆ˜ instanceë¥¼ ë§í•œë‹¤.   
- í•¨ìˆ˜ë¥¼ ë³€ìˆ˜ì²˜ëŸ¼ ë‹¤ë£° ìˆ˜ ìˆì–´ì•¼ í•˜ë¯€ë¡œ, í•¨ìˆ˜í˜• ì–¸ì–´ì—ëŠ” `lambda function`ì„ ì§€ì›í•˜ëŠ” ë¬¸ë²•ì´ ë°˜ë“œì‹œ ì¡´ì¬í•œë‹¤.

> ì´ëŸ° íŠ¹ì„±ì„ ê°•ì¡°í•  ë•Œ, í•¨ìˆ˜ë¥¼ `1ê¸‰ ê°ì²´`ë¡œ ë‹¤ë£¬ë‹¤ê³  í‘œí˜„í•œë‹¤.  
> lambda ë¬¸ë²•ì´ ìˆê³ , function instanceë¥¼ ë³€ìˆ˜ì²˜ëŸ¼ ë‹¤ë£° ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤.

---

```mermaid
flowchart TD
  C{Function}
  C --> D[ì¼ë°˜ í•¨ìˆ˜] 
  C --> E[ê³ ì°¨í•¨ìˆ˜ HOF: Higher-order function] --> F1[í•¨ìˆ˜ ì¡°í•©ê¸° Function combinator]
```
## Higher-Order Functions ( ê³ ì°¨í•¨ìˆ˜; HOF )

í•¨ìˆ˜ë¥¼ `1ê¸‰ ê°ì²´`ë¡œ ë‹¤ë£¨ê¸° ë•Œë¬¸ì—, ì–´ë–¤ í•¨ìˆ˜ê°€ ì¸ì ë˜ëŠ” ë°˜í™˜ê°’ìœ¼ë¡œ function instanceë¥¼ ë°›ì„ ìˆ˜ ìˆê³ ,
ì´ëŸ° í•¨ìˆ˜ë¥¼ í†µìƒì˜ í•¨ìˆ˜ì™€ êµ¬ë¶„í•˜ê¸° ìœ„í•´ `ê³ ì°¨í•¨ìˆ˜`( `Higher-order function`)ì´ë¼ê³  í•œë‹¤.

> A __higher-order__ function is a function that *accepts* __or__ *returns* a function.

```scala
trait List[A] {
  def filter(f: A => Boolean): List[A]
}
```

*ì˜ˆ*
`List[A].filter`ëŠ” `A => Boolean` í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê³    
`List[A]` ê°’ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ì¸ë°, ì¸ìê°€ í•¨ìˆ˜ì´ë¯€ë¡œ ê³ ì°¨ í•¨ìˆ˜ì´ë‹¤.

## Combinators (ì¡°í•©ê¸°)

ê³ ì°¨í•¨ìˆ˜ì˜ íŠ¹ìˆ˜í•œ í˜•íƒœë¡œ, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•  ìˆ˜ ë„ ìˆëŠ”ë°,
ì´ëŸ° í•¨ìˆ˜ë¥¼ `function combinator`(`í•¨ìˆ˜ ì¡°í•¨ê¸°`)ë¼ê³  í•œë‹¤.

> __Function__ combinators are higher-order functions that accept __and__ return functions.  
> __Monad__ combinators are higher-order functions that accept __and__ return `Monad`.
> ( MonadëŠ” ë‚˜ì¤‘ì— ë‹¤ë£¬ë‹¤.)

```scala
type Conf[A] = ConfigReader => A

def string(name: String): Conf[String] = _.readString(name)

def both(left: Conf[A], right: Conf[B]): Conf[(A, B)] = c => (left(c), right(c))
```
`both`ëŠ” ë‘ ê°œì˜ í•¨ìˆ˜ë¥¼ ë°›ê³ , í•˜ë‚˜ì˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ê³ ì°¨í•¨ìˆ˜ì¸ë°, 
ì¸ìì™€ ë°˜í™˜ê°’ ëª¨ë‘ í•¨ìˆ˜ì´ë¯€ë¡œ `combinator`ì´ë‹¤.

---

```mermaid
flowchart TD
  C{Function}
  C --> D[total function ]
  C --> E[partial function] 
```
### Partial function

ì •ì˜ì—­ì˜ ì¼ë¶€ì— ëŒ€í•´ì„œ ì •ì˜ëœ í•¨ìˆ˜ë¥¼ `partial function`ì´ë¼ê³  í•œë‹¤.

```scala
// 0ì´ ì•„ë‹Œ Intì— ëŒ€í•´ ì •ì˜ëœ í•¨ìˆ˜ì´ë‹¤.
val divide: PartialFunction[Int, Int] = {
  case x if x != 0 => 100 / x
}
```

```mermaid
flowchart TD
    C{Function}
    C --> D[monomorphic function ]
    C --> E[polymorphic function] 
```
### polymorphic function

íƒ€ì…(ë“¤)ì„ ì¸ìë¡œ ë°›ì•„ì„œ ì •ì˜ë˜ëŠ” í•¨ìˆ˜ë¥¼ ë§í•œë‹¤.

C++, Java ë“±ì—ì„œëŠ” `generic function` ë˜ëŠ” `generic`ì´ë¼ê³  ë¶€ë¥¸ë‹¤.  
`generic`ì´ë¼ëŠ” í‘œí˜„ì´ ë” ë§ì´ ì‚¬ìš©ë˜ë‹ˆ, ê·¸ê²ƒì„ ì“°ë„ë¡ í•˜ì.

ì¼ë°˜í•¨ìˆ˜ë¥¼ `monomporhpic function` (specific-typed function, concrete function)ì´ë¼ê³  í•  ìˆ˜ ìˆëŠ”ë°
ì‹¤ë¬´ì—ì„œëŠ” êµ³ì´ ì´ ìš©ì–´ë¥¼ ì“¸ì¼ì´ ì—†ë‹¤.

> C++, Java ë“±ì—ì„œ `polymorphic`ì€ íŠ¹ì • íƒ€ì…ì˜ sub-typeë³„ë¡œ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§í•¨.  
> ì°¸ê³ : í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì–¸ì–´ì—ì„œ OOPì˜ polymorphicì€ `type class`ë¡œ êµ¬í˜„ëœë‹¤.

> **note**  
> genericì€ í•¨ìˆ˜í˜• ì–¸ì–´ì˜ ê·¼ê°„ ë¬¸ë²•ì´ê¸° ë•Œë¬¸ì—, ê°„ê²°í•˜ê³  ì‚¬ìš©í•˜ê¸° ì‰¬ìš´ ë¬¸ë²•ì´ ì œê³µë˜ì–´ì•¼ í•œë‹¤.  
> genericë¬¸ë²•ì´ ë³µì¡í•˜ë‹¤ë©´, í•´ë‹¹ ì–¸ì–´ê°€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ì˜ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ë³¼ ìˆ˜ë„ ìˆë‹¤.

```scala
case object identity {
  def apply[A](value: A): A = value
}
identity(3)   // 3
identity("3") // "3"
```

> A polymorphic function is one that is `universally quantified` over one or more type parameters.

`universally quantified`ì€ ì„ì˜ì˜ typeì— ëŒ€í•´ì„œë¼ëŠ” ëœ».
ëŒ€ë¹„ë˜ëŠ” ê°œë…ì„ `existentially quantified`ê°€ ìˆë‹¤.

```haskell
# ëª¨ë“  xì— ëŒ€í•´ì„œ...             ==> universally quantified
# f(x) -> yì¸ y ì¡´ì¬í•˜ë©° ...     ==> existentially quantified
```


**Existential Types**

íƒ€ì…ì´ ìˆ¨ê²¨ì ¸ ìˆê³ , ì–´ë–¤ íƒ€ì…ì´ê¸´ í•˜ì§€ë§Œ ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…ì„ `existentially quantified type`ì´ë¼ í•˜ëŠ”ë°,
ì´ëŸ° ê²½ìš°ì— existential typeì„ ë‹¤ë£¨ëŠ” scalaì½”ë“œì˜ ì‚¬ë¡€ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

Every existential type can be encoded as a universal type. This process is called `skolemization`.
```haskell
# `skolemization` : âˆƒ ê¸°í˜¸ë¥¼ ì—†ì• ê³ , í•¨ìˆ˜ë¡œ ì¹˜í™˜ --> ì¡´ì¬í•˜ëŠ” yë¥¼ capture í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë‚´í¬(closure)
#For every x, there exists a y such that P(x, y) 
âˆ€ ğ‘¥ . âˆƒ ğ‘¦ . ğ‘ƒ ( ğ‘¥ , ğ‘¦ ) â†’ âˆ€ ğ‘¥ . ğ‘ƒ ( ğ‘¥ , ğ‘“ ( ğ‘¥ ) )
```
https://demonstrations.wolfram.com/Skolemization/

```scala
trait ListMap[A] {
  type B
  val list : List[B]
  val mapf : B => A
  
  def run : List[A] = list.map(mapf)
}
```
*Example*
The type `ListMap[A]#B` is some definite type, but there is no way to know what that type is â€” it could be anything.  
Existential types are useful for hiding type information that is not globally relevant.  

ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì‹¤ë¬´ê´€ì ì—ì„œ ì•Œì•„ì•¼ í•  ê²ƒì€
1. existential type ë¬¸ë²• :`ListMap[A]#B`ì—ì„œ BëŠ” ListMap[A]ë‚´ì— ì •ì˜ëœ `existential type`
2. `skolemization`ì€ ì¢…ì¢… `closure`ë¡œ êµ¬í˜„í•œë‹¤.

*ì‚¬ë¡€*
> free monadë¥¼ ë§Œë“¤ë•Œ, ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ëŠ” íƒ€ì…ì„ `existential`ë¡œ ì²˜ë¦¬í•  í•„ìš”ê°€ ìƒê¸°ëŠ”ë°,  
> ê·¸ë•Œ ì•„ë˜ sampleì½”ë“œì™€ ê°™ì€ trickì„ ì‚¬ìš©í•œë‹¤.  

## Evaluation

í•¨ìˆ˜ ë˜ëŠ” í‘œí˜„ì‹(expression)ì„ í‰ê°€í•˜ëŠ” ê²ƒì€ ê³§ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ë‹¤.

```mermaid
flowchart TD
    C{Evaluation of Function}
    C --> D[early evaluation : eager evaluation]
    C --> E[lazy evaluation] 
```
- í‰ê°€ ê²°ê³¼ë¥¼ ë¯¸ë¦¬ ê³„ì‚°í•˜ì—¬ ë™ì‘í•˜ë„ë¡ ë§Œë“œëŠ” ë°©ì‹ì´ early evaluationì´ë‹¤.
- ë°˜ë©´, í‰ê°€ ë°©ë²• ìì²´ë¥¼ ì „ë‹¬í•˜ê³  í•„ìš”í•  ë•Œ ê³„ì‚°í•˜ë„ë¡ í•˜ëŠ” ë°©ì‹ì´ lazy evaluationì´ë‹¤.

> ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ëŠ” `early evaluation`ì„ ì±„íƒí•˜ê³  ìˆìœ¼ë©°, 
> `lazy evaluation`ì„ ë¬¸ë²• ìˆ˜ì¤€ì—ì„œ ì œê³µí•˜ì§€ ì•ŠëŠ” ê²½ìš°, 
> 'ê°’ì„ ì–»ëŠ” í•¨ìˆ˜ ì¡°ê°(chunk)'ì„ ì „ë‹¬í•˜ì—¬ í•„ìš”í•  ë•Œ í‰ê°€í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìš°íšŒ ì²˜ë¦¬í•˜ê³¤ í•œë‹¤.
> 
> ë°˜ë©´, ëŒ€ë¶€ë¶„ì˜ í•¨ìˆ˜í˜• ì–¸ì–´ëŠ” lazy evaluationì„ ë¬¸ë²• ìˆ˜ì¤€ì—ì„œ ì§€ì›í•œë‹¤.
> lazy evaluationì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ë³¸ì§ˆì ì¸ ìš”ì†ŒëŠ” ì•„ë‹ ìˆ˜ ìˆì§€ë§Œ, ì¢…ì¢… ê·¸ íŠ¹ì§• ì¤‘ í•˜ë‚˜ë¡œ ì–¸ê¸‰ëœë‹¤.
> ì‹¤í–‰ìˆœì„œê°€ ê¸°ëŒ€ì™€ ë‹¤ë¥´ê²Œ ë‚˜ì˜¤ëŠ” ê²½ìš°ë„ ìˆìœ¼ë¯€ë¡œ ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤.

---

```mermaid
flowchart TD
  C{type}
  C --> D[concrete type] --> D1[Int, String,...]
  C --> E[type constructor] --> E1[List, Option, ...]
  C --> F[Higher-kinded type] --> F1[ Functor, Monad, Natural Transform, ...]
```

## 1. concrete type (proper type)

ë³´í†µ Typeì´ë¼ê³  í•˜ë©´, `proper type`(ë˜ëŠ” `concrete type`)ì„ ì˜ë¯¸í•˜ëŠ”ë°, 
ê·¸ê²ƒì€ instantiate(ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•´ì„œ ìƒì„±)í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì„ ë§í•œë‹¤.  

*concrete type* : Int, String, List[Int], Map[Int, String], ...

**HashMap[Int, String]**
```mermaid
flowchart TD
  A(HashMap :: Int, String)
```

```scala
// scala
val a : List[Int] = List(1,2,3)
val m : HashMap[Int, String] = HashMap( 1 -> "One", 2 -> "Two")
```

## 2. type constructor

ë°˜ë©´, 
ì˜ˆë¥¼ ë“¤ì–´, List[?]ëŠ” ë‹¨ë…ìœ¼ë¡œ instantiate í•  ìˆ˜ ì—†ê³ ,
ë°˜ë“œì‹œ ì–´ë–¤ ê²ƒ(ì˜ˆë¥¼ ë“¤ë©´ Int)ì— ëŒ€í•œ List ì¸ì§€ ì£¼ì–´ì§ˆ ë•Œë§Œ instantiate í•  ìˆ˜ ìˆë‹¤.

ì´ë ‡ê²Œ concrete type(Int)ì´ ì£¼ì–´ì§ˆ ë•Œ, concrete type(List[Int])ì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” type(List)ì„ 
`type constructor` ë¼ê³  í•œë‹¤.

ì¦‰, ì¸ìì™€ ë°˜í™˜ê°’ì´ ëª¨ë‘ `contrete type`ì´ë©°,
`concrete type`(ë“¤)ì„ ë°›ì•„ì„œ `concrete type`ì„ ë§Œë“œëŠ” í•¨ìˆ˜ë¼ê³  ìƒê°í•  ìˆ˜ ìˆë‹¤.

```mermaid
flowchart TD
  A[Key: Int, Value: String] --> |HashMap| B(HashMap :: Int, String)
```

```scala
// scala
val a : List= ???  // compile error
```

**type constructor**

```mermaid
flowchart TD
  A[concrete type1, concrete type2, ...] --> |type constructor| B(concrete type)
```

## 3. higher-kinded type ( HKT )

í•œë²ˆ ë” ë‚˜ê°€ì„œ ìƒê°í•´ ë³´ë©´, ì¸ì ë˜ëŠ” ë°˜í™˜ê°’ì´ `type constructor` ì¸ ê²½ìš°ë„ ìƒê°í•´ ë³¼ ìˆ˜ ìˆëŠ”ë°,
ì´ê²ƒì„ `Higher-kinded type`(ê³ ì°¨íƒ€ì…, ë˜ëŠ” `Higher-order type`)ì´ë¼ê³  í•œë‹¤.

```mermaid
flowchart TD
  A[Key: Int] --> |Higher order type| B(HashMap:: Int, ???)
```

`HashMap:: Int, ???`ëŠ” `type constructor`ë¡œì„œ, valueì˜ (`concrete`)íƒ€ì…ì´ Stringìœ¼ë¡œ ì£¼ì–´ì§€ë©´
`HashMap:: Int, String`ì„ ë§Œë“ ë‹¤.

```mermaid
flowchart TD
  C[Value: String] --> |HashMap:: Int, ???| D(HashMap :: Int, String)
```

## 4. Summary :: (concrete) Type, Type Constructor, Higher-Order Type

ë„“ì€ ì˜ë¯¸ì˜ `type`ì€ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ë¥˜í•  ìˆ˜ ìˆë‹¤.

1. **Concrete type (Proper type)**
  - ì‹¤ì œ ê°’(instances)ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” íƒ€ì….
  - ì˜ˆ: `Int`, `String`, `List[Int]`
  - ë‹¨ë…ìœ¼ë¡œ instantiate ê°€ëŠ¥í•˜ë‹¤.
  - ì¢ì€ ì˜ë¯¸ì—ì„œ `type`ì€ `concrete type`

2. **Type constructor**
  - type(ë“¤)ì„ ë°›ì•„ì„œ ìƒˆë¡œìš´ `type`(ë³´í†µì€ `concrete type`)ì„ ë§Œë“¬
  - ì˜ˆ: `List`, `Option`, `Either`
  - `type constructor`ê°€ ì•„ë˜ì˜ `higher-kinded type`ì„ í¬í•¨í•˜ëŠ” ì˜ë¯¸ë¡œ ì“°ê¸°ì´ê³  í•¨.

3. **Higher-kinded type(Higher-order type)**
  - ì¸ì ë˜ëŠ” ë°˜í™˜ê°’ì— type constructorê°€ í¬í•¨
  - ì˜ˆ: `Functor[F[_]]`, `Monad[M[_]]`
  - `concrete type`ê³¼ ëŒ€ë¹„ë˜ëŠ” ìš©ì–´ë¡œ `type constructor`ì™€ `higher-kinded type`ë¥¼ í˜¼ìš©í•˜ê¸°ë„ í•¨.

## 5. Kind

- `kind`ëŠ” **íƒ€ì…ì˜ íƒ€ì…**ì„ ë‚˜íƒ€ë‚¸ë‹¤.
- `type`ì„ "í˜•ì‹(signature)" ìœ¼ë¡œ êµ¬ë¶„í•˜ëŠ” ê°œë…
- `kind`ë¥¼ í†µí•´ íƒ€ì…ì´ ëª‡ ê°œì˜ concrete typeì´ë‚˜ type constructorë¥¼ ë°›ì•„ì„œ ìƒˆë¡œìš´ íƒ€ì…ì„ ìƒì„±í•˜ëŠ”ì§€ í‘œí˜„í•  ìˆ˜ ìˆìŒ

| Kind                   | desc                                        | example                      |
|------------------------|---------------------------------------------|------------------------------|
| `*`                    | concrete type                               | `Int`, `String`, `List[Int]` |
| `* -> *`               | type constructor ( unary type constructor)  | `List`, `Option`             |
| `(*, *) -> *`          | type constructor ( binary type constructor) | `Either`, `Tuple2`           |
| `(* -> *) -> *`        | higher-kinded type                          | `Functor[F[_]]`              |
| `(* -> *) -> (* -> *)` | higher-kinded type                          | `Compose[F[_], G[_]]`        |
| `*-> * -> *`           | higher-kinded type                          | curried `HashMap`            |
| `* -> (* -> *)`        | higher-kinded type or type constructor      | `List`, `Option`             |


- Typeì€ í¬ê²Œ **concrete type**, **type constructor**, **higher-kinded type**ìœ¼ë¡œ ë‚˜ë‰œë‹¤.
- Type constructorëŠ” **ì¸ìë¡œ ë°›ëŠ” concrete typeì˜ ê°œìˆ˜**ì— ë”°ë¼ ë‹¤ì–‘í•œ í˜•íƒœê°€ ì¡´ì¬í•œë‹¤.
- Higher-kinded typeì€ **type constructorë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ ë°˜í™˜**í•˜ëŠ” typeì´ë‹¤.
- Kindë¥¼ í†µí•´ ê³ ì°¨íƒ€ì… ë˜ëŠ” íƒ€ì…ìƒì„±ìë¥¼ ë¶„ë¥˜í•  ìˆ˜ ìˆë‹¤.

> `* -> ( * -> *)`
> `(* -> *)`(type constructor)ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ higher-kinded typeì¸ë°,
> ë°˜í™˜íƒ€ì…ì´ `(* -> *)`(type constructor)ì¸ íƒ€ì…ìƒì„±ìë¡œ ë¶€ë¥¼ ìˆ˜ë„ ìˆë‹¤.
> í˜„ì—…ê°œë°œì—ì„œ ë‘ ìš©ì–´ì˜ êµ¬ë¶„ì‹¤ìµì€ ì ìœ¼ë©°, í˜¼ìš©í•˜ì—¬ ì‚¬ìš©ë˜ë‹ˆ ì—…ë°€í•œ êµ¬ë¶„ì— ì‹ ê²½ì“¸ í•„ìš”ëŠ” ì—†ë‹¤.

### Insight of kind

> **`kind`ë¼ëŠ” ê°œë…ì´ í•„ìš”í•œ ì´ìœ **  
> `kind`ëŠ” ë‹¨ìˆœíˆ íƒ€ì…ì„ ë¶„ë¥˜í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼,
> **generic íƒ€ì… ìœ„ì— ê³ ì°¨ ì¶”ìƒí™”ë¥¼ ì•ˆì „í•˜ê²Œ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ë©”íƒ€ êµ¬ì¡°**ì˜ ì—­í• ì„ í•œë‹¤.

1. ê³ ì°¨ íƒ€ì… ì§€ì›
   - Functor, Monad ê°™ì€ íƒ€ì… í´ë˜ìŠ¤ëŠ” List, Option, Eitherì²˜ëŸ¼ íƒ€ì… ìƒì„±ìì— ëŒ€í•´ ì •ì˜ë¨.
   - ex) FunctorëŠ” `* â†’ *` kindë¥¼ ìš”êµ¬í•˜ë¯€ë¡œ, ListëŠ” ê°€ëŠ¥í•˜ì§€ë§Œ IntëŠ” ë¶ˆê°€ëŠ¥
   - kindë¥¼ í†µí•´ `type class`ê°€ ì–´ë–¤ `type constructor`ì— ì ìš© ê°€ëŠ¥í•œì§€ íŒë‹¨í•  ìˆ˜ ìˆìŒ.
   - `type class`ëŠ” ë‹¤ìŒ ì ˆ ì°¸ê³ 

2. íƒ€ì… ì¶”ë¡ ê³¼ ì»´íŒŒì¼ëŸ¬ ê²€ì¦
   - ì»´íŒŒì¼ëŸ¬ëŠ” kind ì •ë³´ë¥¼ í†µí•´ íƒ€ì… ì¸ìê°€ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ ê²€ì¦ 
   - Haskellì—ì„œëŠ” í”„ë¡œê·¸ë¨ì˜ íŠ¹ì •ì„±ì§ˆì„ ì»´íŒŒì¼íƒ€ì„ì— ì¦ëª… í•˜ëŠ” ê¸°ëŠ¥ì´ ë”°ë¡œ ìˆë‹¤.!!!

3. Generic í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ ì•ˆì •ì„±
   - kindëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ì˜ êµ¬ì¡°ë¥¼ ëª…í™•íˆ í•˜ì—¬ generic í•¨ìˆ˜ë‚˜ íƒ€ì…ì„ ì •ì˜í•  ë•Œ íƒ€ì… ì•ˆì •ì„±ì„ ë³´ì¥ 
   - ex: map :: Functor[F[_]]ì—ì„œ FëŠ” ë°˜ë“œì‹œ `* â†’ *` kindì—¬ì•¼ í•¨.

## 6. Type Class

`type class`ëŠ” ì–´ë–¤ íŠ¹ì • `type`(`higher-kinded type`ì´ë‚˜ `type constructor`ë¥¼ ì—¼ë‘ì— ë‘ì–´ì•¼ í•œë‹¤)ì— ëŒ€í•´ 
ë™ì‘í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ ë˜ëŠ” ì œì•½ì¡°ê±´ ì´ë‹¤.

```scala
// type class in scala
/*
  type class ì •ì˜
*/
trait Show[A] {
  def show(a: A): String
}

/*
  type classë¥¼ ë§Œì¡±ì‹œí‚¤ëŠ” type class ì¸ìŠ¤í„´ìŠ¤ë“¤
  í•„ìš”í•œë§Œí¼ ê³„ì† ì¶”ê°€í•˜ë©´ ëœë‹¤.
*/
implicit val intShow: Show[Int]
= new Show[Int] { def show(a: Int): String = s"Int($a)" }

implicit val stringShow: Show[String]
= new Show[String] { def show(a: String): String = s"String('$a')" }

/* 
  type classë¥¼ ì‚¬ìš©í•˜ëŠ” ì½”ë“œ
  (implicit sh: Show[A]) 
  Aë¼ëŠ” íƒ€ì…ì— ëŒ€í•´ì„œ Showë¼ëŠ” type classê°€ ì¡´ì¬í•´ì•¼ í•œë‹¤ëŠ” ëœ».
*/
def printShow[A](a: A)(implicit sh: Show[A]): Unit = {
  println(sh.show(a))
}
```

ìœ„ì˜ ìƒ˜í”Œì€ `concrete type`ì— ëŒ€í•œ `type class`ì´ë¯€ë¡œ OOPì˜ ìƒì†ì„ ì“°ëŠ” ê²ƒê³¼ í° ì°¨ì´ ì—†ëŠ” ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.

```scala
// * -> *  íƒ€ì…ì— ëŒ€í•œ type class
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

// * -> *  íƒ€ì…ì¸ Listì— ëŒ€í•œ type class ì¸ìŠ¤í„´ìŠ¤
implicit val listFunctor: Functor[List] = new Functor[List] {
  def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)
}

// type class ë¥¼ ì‚¬ìš©í•˜ëŠ” ì½”ë“œ
def convert[F[_], A, B](f: A => B)(implicit functor: Functor[F]): F[A] => F[B] =
  fa => functor.map(fa)(f)

val converted: List[Int] => List[String] = convert((x: Int) => s"Number: $x")
val result = converted(List(1, 2, 3))

```

ë‹¨ìˆœí•œ íƒ€ì…ì´ ì•„ë‹Œ ê³ ì°¨íƒ€ì…(List, Option ë“±)ì— ëŒ€í•´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ê³ ,    
ì´ë¥¼ ì•”ë¬µì ìœ¼ë¡œ ì£¼ì…ë°›ì•„ ì¼ë°˜í™”ëœ í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•œ ê²ƒì´ë‹¤.

> note : `type class`ëŠ” í•¨ìˆ˜í˜• ì–¸ì–´ì—ì„œ ê±°ì˜ ë¹ ì§ì—†ì´ ë“±ì¥í•œë‹¤.

## 6. ADT ( Algebraic Data Type)

ëŒ€ìˆ˜ì  íƒ€ì…(`ADT`)ì€ íƒ€ì…ê³¼ íƒ€ì…ì— ì •ì˜ëœ ì—°ì‚°ì˜ ë¬¶ìŒìœ¼ë¡œ êµ¬ì„±ëœë‹¤.
ì•ì„œ ì‚´í´ë³¸ ëª¨ë“  `type`ë“¤ì€ ì¼ì¢…ì˜ `ADT`ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.

> ì˜ˆë¥¼ ë“¤ì–´, `ì •ìˆ˜ Monoid`ëŠ” ì–´ë–¤ ì—°ì‚°(ex: ë§ì…ˆ)ì— ë‹«íŒ ì •ìˆ˜ì˜ ì§‘í•©ìœ¼ë¡œ ì •ì˜ëœë‹¤.

íƒ€ì…ë“¤ì„ ì¡°í•©í•˜ì—¬ ìƒˆë¡œìš´ `ADT`ë¥¼ ìƒì„±í•˜ëŠ” ë‘ê°€ì§€ ë°©ë²•ì„ ì‚´í´ë³¸ë‹¤.

### Product Type

ê³±íƒ€ì…(`prodcut type`)ì€ ì—¬ëŸ¬ íƒ€ì…ë“¤ì„ *Cartesian cross product*ìœ¼ë¡œ ì¡°í•©í•˜ì—¬ ë§Œë“  íƒ€ì….

> Product types are defined by a *Cartesian cross product* on 2 or more types.

```scala
type Point2D = (Int, Int)
```
*Example*: 2ì°¨ìœˆì˜ ì ì€ (x, y) ì¦‰, ë‘ê°œì˜ ìˆ«ìë¡œ ë§Œë“  `product type`ì´ë‹¤.

#### Case Classes
`product type`ì„ ë§Œë“œëŠ” ë¬¸ë²•ì€ ê±°ì˜ ëª¨ë“  ì–¸ì–´ì— ìˆë‹¤.  
êµ¬ì¡°ì²´, class, íŠœí”Œ ë“±ì„ ì´ìš©í•˜ì—¬ `product type`ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.   
scalaì˜ `case classë¬¸ë²•`ì€ `product type`ì œì‘ ì „ìš© ë¬¸ë²•ì´ë¼ê³  ë³¼ ìˆ˜ ë„ ìˆë‹¤.

> In Scala, case classes are the idiomatic representation of product types. The terms of a case class are identified by *name*.

```scala
case class Person(name: String, age: Int)
```
*Example*: PersonëŠ” `name` **ê³¼(and)**  `age`ë¥¼ ê°–ëŠ”ë‹¤. (ë°˜ë“œì‹œ ë‘˜ë‹¤ ê°€ì§.)


### Sum Types ( co-product type)

í•©íƒ€ì…(`Sum Type` ( `co-product type`)ì€ ì—¬ëŸ¬ íƒ€ì…ë“¤ì„ *disjoint union*ìœ¼ë¡œ ì¡°í•©í•˜ì—¬ ë§Œë“  íƒ€ì…ì´ë‹¤.

> Sum types are defined by a *disjoint union* on 2 or more types.

```scala
type RequestResult = Either[Error, HttpResponse]
```
*Example*: RequestResultëŠ” `Error` **ë˜ëŠ”(or)**  `HttpResponse`ë¥¼ ê°–ëŠ”ë‹¤. (ë‘˜ë‹¤ ë™ì‹œì— ê°–ì§€ ì•ŠìŒ)

#### Sealed Traits

`sealed trait`ì€ scalaì—ì„œ `sum type`ì„ ë§Œë“œëŠ” ë¬¸ë²•ì´ë‹¤.
> note: `sum type`ì‘ì„±ë°©ë²•ì„ ë¬¸ë²•ìˆ˜ì¤€ì—ì„œ ì œê³µí•˜ì§€ ì•ŠëŠ” í”„ë¡œê·¸ë¨ ì–¸ì–´ë“¤ì´ ìƒê°ë³´ë‹¤ ë§ë‹¤.


```scala
sealed trait AddressType
case object Home     extends AddressType
case object Business extends AddressType
```
*Example*: `AddressType`ì€ `Home` **ë˜ëŠ”** `Business`ì´ë‹¤.
